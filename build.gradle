plugins {
  id "com.github.jk1.dependency-license-report" version "1.16"
  id 'org.unbroken-dome.test-sets' version '4.0.0'
}

import com.github.jk1.license.importer.XmlReportImporter
import org.apache.tools.ant.filters.ReplaceTokens

apply plugin: 'java'
apply plugin: 'application'

repositories {
  mavenCentral()
  maven { url 'https://oss.sonatype.org/content/repositories/snapshots' }
}

version = "4.3.9-SNAPSHOT"

def targetJavaRelease = 11
def jvmVersion = System.getProperty("os.arch").equals("aarch64") ? "17" : "11" // Only 17 is available for Apple silicon.
def testJvmVersion = project.findProperty("testJvmVersion") ?: jvmVersion
def jvmVendor = JvmVendorSpec.ADOPTIUM
println "Compiling for Java ${targetJavaRelease} using JVM ${jvmVersion} (${jvmVendor}), testing using JVM ${testJvmVersion}"

tasks.withType(JavaCompile).configureEach { options.release = targetJavaRelease }

java {
  toolchain {
    languageVersion = JavaLanguageVersion.of(jvmVersion)
    vendor = jvmVendor
  }
}

// https://github.com/unbroken-dome/gradle-testsets-plugin
testSets {
  integrationTest
}

integrationTest {
  minHeapSize = "128m"
  maxHeapSize = "512m"
  jvmArgs '-verbose:gc', '-XX:+HeapDumpOnOutOfMemoryError'
}

tasks.withType(Test) {
  testLogging.showStandardStreams = true
  javaLauncher = javaToolchains.launcherFor {
    languageVersion = JavaLanguageVersion.of(testJvmVersion)
    vendor = jvmVendor
  }
}

integrationTest.dependsOn(test)

task exhaustiveTest(group: "Verification", description: "Runs the integration tests against *all* supported server versions") {
  doLast {
    tasks.withType(Test) {
      systemProperty 'com.couchbase.integrationTest.exhaustive', 'true'
    }
  }
  finalizedBy integrationTest
}

dependencies {
  implementation 'org.apache.logging.log4j:log4j-slf4j-impl:2.19.0'

  // Elasticsearch High Level REST client uses commons-logging.
  // Route that through SLF4J instead.
  implementation 'org.slf4j:jcl-over-slf4j:1.7.36'

  implementation 'com.couchbase.client:java-client:3.3.1'
  implementation 'com.couchbase.client:dcp-client:0.40.0'

  // Can't upgrade ES client to 7.x until we drop support for ES 6
  //   because the 7.x client omits the document type field required by 6.
  // Can't upgrade ES client to 6.8 because it's not forwards compatible with ES 7
  //   due to a change in how warnings are returned in HTTP responses.
  implementation 'org.elasticsearch.client:elasticsearch-rest-high-level-client:6.7.1'

  // Transitive dependencies of Elasticsearch client.
  // Force newer versions to ward off vulnerability reports.
  implementation platform("com.fasterxml.jackson:jackson-bom:2.14.1")
  implementation 'commons-codec:commons-codec:1.15'
  implementation 'org.apache.httpcomponents:httpclient:4.5.13'
  implementation 'org.apache.httpcomponents:httpasyncclient:4.1.5'
  implementation 'org.apache.httpcomponents:httpcore:4.4.15'
  implementation 'org.apache.httpcomponents:httpcore-nio:4.4.15'

  implementation 'io.projectreactor:reactor-core:3.4.17'

  implementation 'io.fabric8:kubernetes-client:5.11.1'
  implementation 'com.orbitz.consul:consul-client:1.3.3'
  implementation 'com.github.therapi:therapi-json-rpc:0.5.0'

  implementation 'io.micrometer:micrometer-registry-prometheus:1.8.1'
  implementation 'io.dropwizard.metrics:metrics-json:4.2.7'
  implementation 'io.dropwizard.metrics:metrics-jvm:4.2.7'

  implementation 'com.google.guava:guava:31.1-jre'
  implementation 'org.apache.commons:commons-text:1.10.0'
  implementation 'org.apache.tuweni:tuweni-toml:2.0.0'

  implementation 'net.sf.jopt-simple:jopt-simple:5.0.4'
  implementation 'info.picocli:picocli:4.6.3'

  implementation 'com.amazonaws:aws-java-sdk-core:1.12.213'

  testImplementation 'junit:junit:4.13.2'
  testImplementation 'org.apache.commons:commons-lang3:3.12.0'
  testImplementation 'commons-io:commons-io:2.11.0'
  testImplementation('org.assertj:assertj-core:3.22.0')
  integrationTestImplementation 'com.jayway.jsonpath:json-path:2.7.0'

  def testcontainersVersion = '1.16.2'
  integrationTestImplementation "org.testcontainers:testcontainers:${testcontainersVersion}"
  integrationTestImplementation "org.testcontainers:couchbase:${testcontainersVersion}"
  integrationTestImplementation "org.testcontainers:elasticsearch:${testcontainersVersion}"

  compileOnly 'org.immutables:value:2.8.8'
  annotationProcessor 'org.immutables:value:2.8.8'
}

configurations.all {
  exclude group: 'commons-logging' // using jcl-over-slf4j instead
  resolutionStrategy.cacheChangingModulesFor 0, 'seconds' // always update snapshots instead of waiting 24 hrs
}

// The "aws-request-signing-apache-interceptor" dependency is included in source form
// because it's not published to a public repo. Include it in the dependency report.
licenseReport {
  importers = [new XmlReportImporter('Additional dependencies', file("additional-license-info.xml"))]
}

// Prohibit snapshot dependencies unless we're building a snapshot
if (!version.endsWith("SNAPSHOT")) {
  configurations.all {
    resolutionStrategy.eachDependency { details ->
      if (details.requested.version.endsWith("-SNAPSHOT")) {
        throw new GradleException("Can't release with SNAPSHOT dependency: $details.requested")
      }
    }
  }
}

// IntelliJ doesn't play nice with classes generated by annotation processors.
// This dirty workaround aligns Gradle with IDEA's default behavior so we can use org.immutables.
// Assumes IDEA is storing generated sources relative to the module content root,
// using the default directory name of "generated"
ext.generatedFilesDir = file('src/main/generated')
compileJava.options.annotationProcessorGeneratedSourcesDirectory = generatedFilesDir
sourceSets.main.java.srcDirs += generatedFilesDir
clean {
  delete generatedFilesDir
}

tasks.withType(Tar) {
  compression = Compression.GZIP
}

// Patch the start scripts to export the APP_HOME environment variable
// so we can read log4j config and write log files in usual location.
// See https://discuss.gradle.org/t/linux-launcher-script-should-export-app-home-before-starting-the-application/3570
tasks.withType(CreateStartScripts) {
  doLast {
    unixScript.text = unixScript.text.replace('exec', 'export APP_HOME; exec')
    // Apparently the Windows launcher already exposes the variable (NOT VERIFIED)

    // tidy up the class path, yeah? Maybe add $APP_HOME/lib-ext as well?
    unixScript.text = unixScript.text.replaceAll('CLASSPATH=.*', 'CLASSPATH=\\$APP_HOME/lib/*')
    //windowsScript.text = windowsScript.text.replaceAll('CLASSPATH=.*', 'CLASSPATH=%APP_HOME%\\\\lib\\\\*')
  }
}

mainClassName = "com.couchbase.connector.elasticsearch.ElasticsearchConnector"
applicationDefaultJvmArgs = ['-server']

startScripts {
  applicationName = 'cbes'
}

def extraStartScripts = [
    'cbes-checkpoint-backup' : 'com.couchbase.connector.elasticsearch.cli.CheckpointBackup',
    'cbes-checkpoint-restore': 'com.couchbase.connector.elasticsearch.cli.CheckpointRestore',
    'cbes-checkpoint-clear'  : 'com.couchbase.connector.elasticsearch.cli.CheckpointClear',
    'cbes-consul'            : 'com.couchbase.connector.elasticsearch.cli.ConsulCli'
]

extraStartScripts.each { scriptName, driverClass ->
  Task t = task(scriptName + "-script", group: 'CLI Script Generation', type: CreateStartScripts) {
    mainClass = driverClass
    applicationName = scriptName
    outputDir = startScripts.outputDir
    classpath = startScripts.classpath
  }
  startScripts.dependsOn(t)
}

def requireFileExists(filename)  {
  if (!file(filename).exists()) throw new GradleException("File '$filename' not found")
  return filename
}

def readmeFilename = requireFileExists("DIST_README.txt")
applicationDistribution.from(".") {
  include(readmeFilename, requireFileExists("LICENSE"))
  rename(readmeFilename, 'README.txt')
}

applicationDistribution.into("notices") {
  // https://github.com/jk1/Gradle-License-Report
  from(generateLicenseReport)
}

def getGitInfo() {
  def stdout = new ByteArrayOutputStream()
  exec {
    commandLine 'git', 'describe', '--tags', '--dirty', '--always'
    standardOutput = stdout
  }
  return stdout.toString().trim()
}

def gitInfo = getGitInfo()

//if (gitInfo.contains("dirty")) {
//    println "WARNING: workspace is dirty"
//}

processResources {
  inputs.property("version", project.property("version"))
  inputs.property("gitInfo", gitInfo)

  filteringCharset = 'UTF-8'
  filesMatching('**/*.properties') {
    filter ReplaceTokens, tokens: [
        "application.version": project.property("version"),
        "git.info"           : gitInfo
    ]
  }
}
